"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[5885],{3905:(e,t,s)=>{s.d(t,{Zo:()=>d,kt:()=>h});var a=s(67294);function n(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function l(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,a)}return s}function r(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?l(Object(s),!0).forEach((function(t){n(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):l(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function o(e,t){if(null==e)return{};var s,a,n=function(e,t){if(null==e)return{};var s,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)s=l[a],t.indexOf(s)>=0||(n[s]=e[s]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)s=l[a],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(n[s]=e[s])}return n}var i=a.createContext({}),p=function(e){var t=a.useContext(i),s=t;return e&&(s="function"==typeof e?e(t):r(r({},t),e)),s},d=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var s=e.components,n=e.mdxType,l=e.originalType,i=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(s),m=n,h=u["".concat(i,".").concat(m)]||u[m]||c[m]||l;return s?a.createElement(h,r(r({ref:t},d),{},{components:s})):a.createElement(h,r({ref:t},d))}));function h(e,t){var s=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=s.length,r=new Array(l);r[0]=m;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[u]="string"==typeof e?e:n,r[1]=o;for(var p=2;p<l;p++)r[p]=s[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,s)}m.displayName="MDXCreateElement"},93429:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=s(87462),n=(s(67294),s(3905));const l={id:"PIXI.Assets.pixi_assets",title:"Namespace: PIXI.Assets",sidebar_label:"PIXI.Assets",custom_edit_url:null},r=void 0,o={unversionedId:"api/namespaces/PIXI.Assets.pixi_assets",id:"api/namespaces/PIXI.Assets.pixi_assets",title:"Namespace: PIXI.Assets",description:"@pixi/assets.Assets",source:"@site/docs/api/namespaces/PIXI.Assets.pixi_assets.mdx",sourceDirName:"api/namespaces",slug:"/api/namespaces/PIXI.Assets.pixi_assets",permalink:"/api/namespaces/PIXI.Assets.pixi_assets",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{id:"PIXI.Assets.pixi_assets",title:"Namespace: PIXI.Assets",sidebar_label:"PIXI.Assets",custom_edit_url:null},sidebar:"apiSidebar",previous:{title:"@pixi/utils",permalink:"/api/modules/pixi_utils"},next:{title:"PIXI.canvasUtils",permalink:"/api/namespaces/PIXI.canvasUtils.pixi_canvas_renderer"}},i={},p=[{value:"Assets Loading",id:"assets-loading",level:3},{value:"Textures",id:"textures",level:3},{value:"Sprite sheets",id:"sprite-sheets",level:4},{value:"Fonts",id:"fonts",level:3},{value:"Background Loading",id:"background-loading",level:3},{value:"Manifest and Bundles",id:"manifest-and-bundles",level:3},{value:"Members",id:"members",level:2},{value:"cache: <span><code>PIXI.Cache</code></span>",id:"cache-pixicache",level:3},{value:"detections: <span><code>FormatDetectionParser[]</code></span>",id:"detections-formatdetectionparser",level:3},{value:"loader: <span><code>PIXI.AssetLoader</code></span>",id:"loader-pixiassetloader",level:3},{value:"preferWorkers: <span><code>boolean</code></span>",id:"preferworkers-boolean",level:3},{value:"resolver: <span><code>Resolver</code></span>",id:"resolver-resolver",level:3}],d={toc:p};function u(e){let{components:t,...s}=e;return(0,n.kt)("wrapper",(0,a.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"../modules/pixi_assets"},"@pixi/assets"),".Assets"),(0,n.kt)("p",null,"A one stop shop for all Pixi resource management! Super modern and easy to use, with enough flexibility to customize and do what you need!"),(0,n.kt)("p",null,"Only one Asset Class exists accessed via the Global Asset object."),(0,n.kt)("p",null,"It has four main responsibilities",":"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Allows users to map URLs to keys and resolve them according to the user's browser capabilities"),(0,n.kt)("li",{parentName:"ol"},"Loads the resources and transforms them into assets that developers understand."),(0,n.kt)("li",{parentName:"ol"},"Caches the assets and provides a way to access them."),(0,n.kt)("li",{parentName:"ol"},"Allow developers to unload assets and clear the cache.")),(0,n.kt)("p",null,"It also has a few advanced features",":"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'."),(0,n.kt)("li",{parentName:"ol"},"Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature, in-game loading bars can be a thing of the past!")),(0,n.kt)("h3",{id:"assets-loading"},"Assets Loading"),(0,n.kt)("p",null,"Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once."),(0,n.kt)("p",null,"For example",":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"import { Assets } from 'pixi.js';\n\npromise1 = Assets.load('bunny.png')\npromise2 = Assets.load('bunny.png')\n\n// promise1 === promise2\n\n")),(0,n.kt)("p",null,"Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!"),(0,n.kt)("p",null,"Out of the box it supports the following files",":"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"textures (avif, webp, png, jpg, gif, svg)"),(0,n.kt)("li",{parentName:"ul"},"sprite sheets (json)"),(0,n.kt)("li",{parentName:"ul"},"bitmap fonts (xml, fnt, txt)"),(0,n.kt)("li",{parentName:"ul"},"web fonts (ttf, woff, woff2)"),(0,n.kt)("li",{parentName:"ul"},"json files (json)"),(0,n.kt)("li",{parentName:"ul"},"text files (txt)")),(0,n.kt)("p",null,"More types can be added fairly easily by creating additional loader parsers."),(0,n.kt)("h3",{id:"textures"},"Textures"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times."),(0,n.kt)("li",{parentName:"ul"},"By default, we will prefer to load AVIF and WebP image files if you specify them. But if the browser doesn't support AVIF or WebP we will fall back to png and jpg."),(0,n.kt)("li",{parentName:"ul"},"Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!"),(0,n.kt)("li",{parentName:"ul"},"Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)")),(0,n.kt)("h4",{id:"sprite-sheets"},"Sprite sheets"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"It's hard to know what resolution a sprite sheet is without loading it first, to address this there is a naming convention we have added that will let Pixi understand the image format and resolution of the spritesheet via its file name",":")),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"my-spritesheet{resolution}.{imageFormat}.json")),(0,n.kt)("p",null,"For example",":"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"my-spritesheet@2x.webp.json")," // 2x resolution, WebP sprite sheet",(0,n.kt)("inlineCode",{parentName:"p"},"my-spritesheet@0.5x.png.json")," // 0.5x resolution, png sprite sheet"),(0,n.kt)("p",null,"This is optional! You can just load a sprite sheet as normal. This is only useful if you have a bunch of different res / formatted spritesheets."),(0,n.kt)("h3",{id:"fonts"},"Fonts"),(0,n.kt)("p",null,"Web fonts will be loaded with all weights. It is possible to load only specific weights by doing the following",":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"import { Assets } from 'pixi.js';\n\n// Load specific weights..\nawait Assets.load({\n    data: {\n        weights: ['normal'], // Only loads the weight\n    },\n    src: `outfit.woff2`,\n});\n\n// Load everything...\nawait Assets.load(`outfit.woff2`);\n\n")),(0,n.kt)("h3",{id:"background-loading"},"Background Loading"),(0,n.kt)("p",null,"Background loading will load stuff for you passively behind the scenes. To minimize jank, it will only load one asset at a time. As soon as a developer calls ",(0,n.kt)("inlineCode",{parentName:"p"},"Assets.load(...)")," the background loader is paused and requested assets are loaded as a priority. Don't worry if something is in there that's already loaded, it will just get skipped!"),(0,n.kt)("p",null,"You still need to call ",(0,n.kt)("inlineCode",{parentName:"p"},"Assets.load(...)")," to get an asset that has been loaded in the background. It's just that this promise will resolve instantly if the asset has already been loaded."),(0,n.kt)("h3",{id:"manifest-and-bundles"},"Manifest and Bundles"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Manifest is a JSON file that contains a list of all assets and their properties."),(0,n.kt)("li",{parentName:"ul"},"Bundles are a way to group assets together.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"import { Assets } from 'pixi.js';\n\n// Manifest Example\nconst manifest = {\n    bundles: [\n        {\n            name: 'load-screen',\n            assets: [\n                {\n                    name: 'background',\n                    srcs: 'sunset.png',\n                },\n                {\n                    name: 'bar',\n                    srcs: 'load-bar.{png,webp}',\n                },\n            ],\n        },\n        {\n            name: 'game-screen',\n            assets: [\n                {\n                    name: 'character',\n                    srcs: 'robot.png',\n                },\n                {\n                    name: 'enemy',\n                    srcs: 'bad-guy.png',\n                },\n            ],\n        },\n    ]\n};\n\nawait Asset.init({ manifest });\n\n// Load a bundle...\nloadScreenAssets = await Assets.loadBundle('load-screen');\n// Load another bundle...\ngameScreenAssets = await Assets.loadBundle('game-screen');\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"}," import { Assets } from 'pixi.js';\n\n const bunny = await Assets.load('bunny.png');\n")),(0,n.kt)("p",null,"// TODO: @see"),(0,n.kt)("h2",{id:"members"},"Members"),(0,n.kt)("article",null,(0,n.kt)("h3",{id:"cache-pixicache"},"cache: ",(0,n.kt)("span",null,(0,n.kt)("code",null,"PIXI.Cache"))),(0,n.kt)("p",null,"The global cache of all assets within PixiJS")),(0,n.kt)("hr",null),(0,n.kt)("article",null,(0,n.kt)("h3",{id:"detections-formatdetectionparser"},"detections: ",(0,n.kt)("span",null,(0,n.kt)("code",null,"FormatDetectionParser[]"))),(0,n.kt)("p",null,"All the detection parsers currently added to the Assets class.")),(0,n.kt)("hr",null),(0,n.kt)("article",null,(0,n.kt)("h3",{id:"loader-pixiassetloader"},"loader: ",(0,n.kt)("span",null,(0,n.kt)("code",null,"PIXI.AssetLoader"))),(0,n.kt)("p",null,"The loader, loads stuff!")),(0,n.kt)("hr",null),(0,n.kt)("article",null,(0,n.kt)("h3",{id:"preferworkers-boolean"},"preferWorkers: ",(0,n.kt)("span",null,(0,n.kt)("code",null,"boolean"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Default Value"),": ",(0,n.kt)("code",null,"true"))),(0,n.kt)("p",null,"When set to ",(0,n.kt)("inlineCode",{parentName:"p"},"true"),", loading and decoding images will happen with Worker thread, if available on the browser. This is much more performant as network requests and decoding can be expensive on the CPU. However, not all environments support Workers, in some cases it can be helpful to disable by setting to ",(0,n.kt)("inlineCode",{parentName:"p"},"false"),".")),(0,n.kt)("hr",null),(0,n.kt)("article",null,(0,n.kt)("h3",{id:"resolver-resolver"},"resolver: ",(0,n.kt)("span",null,(0,n.kt)("code",null,"Resolver"))),(0,n.kt)("p",null,"the resolver to map various urls")),(0,n.kt)("hr",null))}u.isMDXComponent=!0}}]);