"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[5549],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>g});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),h=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=h(e.components);return r.createElement(c.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=h(t),u=i,g=p["".concat(c,".").concat(u)]||p[u]||d[u]||a;return t?r.createElement(g,s(s({ref:n},l),{},{components:t})):r.createElement(g,s({ref:n},l))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=u;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[p]="string"==typeof e?e:i,s[1]=o;for(var h=2;h<a;h++)s[h]=t[h];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},12549:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=t(87462),i=(t(67294),t(3905));const a={hide_table_of_contents:!0},s="Hit-Testing (spatial hash)",o={unversionedId:"examples/events/hit-testing-with-spatial-hash",id:"examples/events/hit-testing-with-spatial-hash",title:"Hit-Testing (spatial hash)",description:"",source:"@site/docs/examples/events/hit-testing-with-spatial-hash.md",sourceDirName:"examples/events",slug:"/examples/events/hit-testing-with-spatial-hash",permalink:"/examples/events/hit-testing-with-spatial-hash",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/examples/events/hit-testing-with-spatial-hash.md",tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"examplesSidebar",previous:{title:"Dragging",permalink:"/examples/events/dragging"},next:{title:"Interactivity",permalink:"/examples/events/interactivity"}},c={},h=[],l={toc:h};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"hit-testing-spatial-hash"},"Hit-Testing (spatial hash)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:"playground",playground:!0},"// This example shows how you can create your own EventBoundary to accelerate\n// hit-testing using spatial hashes. This can be used to optimize relatively\n// \"flat\" scene graphs, where  a container contains so many objects that it\n// covers the whole scene.\n\n// This special event boundary overrides the hit-testing implementation to use\n// HashingContainer's own childHash to find children near the pointer\n// location.\nclass HashingEventBoundary extends PIXI.EventBoundary {\n    constructor(...args) {\n        super(...args);\n        // Create reusable temp rectangle for hit-testing!\n        this.tempRect = new PIXI.Rectangle();\n    }\n\n    hitTestRecursive(\n        currentTarget,\n        interactive,\n        location,\n        testFn,\n        pruneFn,\n    ) {\n        // If currentTarget isn't a HashingContainer, then default to the\n        // regular hit-testing implementation provided by PixiJS.\n        if (!currentTarget\n                || !currentTarget.visible\n                || !currentTarget.childHash) {\n            return super.hitTestRecursive(\n                currentTarget,\n                interactive,\n                location,\n                testFn,\n                pruneFn,\n            );\n        }\n\n        // Check if the location is outside of the entire container\n        if (pruneFn(currentTarget, location)) return null;\n\n        // Time to get recursive and find the next child in the propagation\n        // path of the event, accelerated using the childHash.\n        if (currentTarget.interactiveChildren) {\n            /* This is where the magic happens! */\n            const tempRect = this.tempRect;\n\n            // Store the location as a 0x0 rectangle. SpatialHash requires a\n            // rectangle for searching.\n            tempRect.x = location.x;\n            tempRect.y = location.y;\n\n            // Find all the children overlapping with tempRect a.k.a location,\n            // and then sort them by their index in the HashingContainer's\n            // children array.\n            const children = Array\n                .from(currentTarget.childHash.search(tempRect))\n                .sort((a, b) => a.refIndex - b.refIndex);\n\n            /* The following is copied from EventBoundary's code. */\n            for (let i = children.length - 1; i >= 0; i--) {\n                const child = children[i];\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    interactive || child.interactive,\n                    location,\n                    testFn,\n                    pruneFn,\n                );\n\n                if (nestedHit) {\n                    // Its a good idea to check if a child has lost its\n                    // parent. this means it has been removed whilst looping\n                    // so its best\n                    if (nestedHit.length > 0\n                            && !nestedHit[nestedHit.length - 1].parent) {\n                        // eslint-disable-next-line no-continue\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test\n                    // chain if the chain has already started (i.e. the event\n                    // target has been found) or if the current target is\n                    // interactive (i.e. it becomes the event target).\n                    if (nestedHit.length > 0 || currentTarget.interactive) {\n                        nestedHit.push(currentTarget);\n                    }\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        /* The following is copied from EventBoundary's own implementation. */\n\n        // Finally, hit test this DisplayObject itself.\n        if (interactive && testFn(currentTarget, location)) {\n            // The current hit-test target is the event's target only if it\n            // is interactive. Otherwise, the first interactive ancestor will\n            // be the event's target.\n            return currentTarget.interactive ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n}\n\n// HashingContainer is a special kind of container that organizes its children\n// in a spatial hash. It also sets each child's refIndex property to its index\n// in the hashing container's children array.\nclass HashingContainer extends PIXI.Container {\n    constructor() {\n        super();\n        this.childHash = new PIXI.SpatialHash();\n    }\n\n    // Override updateTransform to update this.childHash!\n    updateTransform() {\n        super.updateTransform();\n\n        // Reset childHash & re-add all the children. This will\n        // make the spatial hash re-evaluate the coverage of each child.\n        this.childHash.reset();\n        for (let i = 0; i < this.children.length; i++) {\n            const child = this.children[i];\n\n            this.childHash.put(child);\n            child.refIndex = i;\n        }\n    }\n}\n\n// This is the actual program using HashingEventBoundary, HashingContainer.\nfunction main() {\n    // Create app. autoStart = false so that the app doesn't render until\n    // something changes - this prevents redundant spatial-hash updates.\n    const app = new PIXI.Application<HTMLCanvasElement>({\n        antialias: true,\n        autoStart: false,\n        background: '#1099bb',\n    });\n    document.body.appendChild(app.view);\n\n    // Install our own EventBoundary!\n    app.renderer.events.rootBoundary = new HashingEventBoundary(app.stage);\n\n    // Make the hashing container\n    const container = app.stage.addChild(new HashingContainer());\n    // Textures to choose from for each random character\n    const textures = [\n        PIXI.Texture.from('https://beta.pixijs.com/assets/skully.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/eggHead.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/flowerTop.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/helmlok.png'),\n    ];\n    // Rerender scene when each texture loads\n    textures.forEach(\n        (tex) => tex.baseTexture.once('loaded', () => app.render()),\n    );\n\n    // Populate the hashing container!\n    function makeMonster(x, y) {\n        const texture = textures[Math.floor(Math.random() * textures.length)];\n        const sprite = new PIXI.Sprite(texture);\n\n        // Randomly place the character\n        sprite.position.set(\n            x || Math.random() * (app.screen.width - 64),\n            y || (64 + Math.random() * (app.screen.height - 128)),\n        );\n\n        // Make character smaller so we can have a bunch of 'em\n        sprite.scale.set(0.34);\n\n        // Make the character interactive!\n        sprite.interactive = true;\n\n        // Explode on clicks!\n        sprite.addEventListener('click', onMonsterClicked);\n\n        container.addChild(sprite);\n\n        return sprite;\n    }\n    function onMonsterClicked(e) {\n        const monster = this;\n        const pos = monster.position;\n        const radius = Math.max(monster.width, monster.height) * 2;\n\n        // Remove monster from scene once the event finishes propagating.\n        e.manager.dispatch.once('click', () => {\n            // TODO: Fix PixiJS throwing errors since the monster is removed\n            // from scene graph while was under hover.\n\n            monster.parent.removeChild(monster);\n            PIXI.Ticker.shared.addOnce(() => app.render());\n        });\n\n        for (let i = 0; i < 8; i++) {\n            const x = pos.x + radius * Math.cos(i * Math.PI / 4);\n            const y = pos.y + radius * Math.sin(i * Math.PI / 4);\n\n            makeMonster(x, y);\n        }\n    }\n    // Make initial set of monsters\n    for (let i = 0; i < 100; i++) makeMonster();\n\n    // Add a descriptive title\n    const title = app.stage.addChild(\n        new PIXI.Text(\n            'Click on a monster and see it explode into more!',\n            {\n                fontSize: 12,\n            },\n        ),\n    );\n    title.position.set(12, 12);\n\n    // Render the stage once\n    app.render();\n}\n\n// Run our program!\nmain();\n")))}p.isMDXComponent=!0}}]);