"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[1788],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),u=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=u(e.components);return r.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=u(t),h=o,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||a;return t?r.createElement(m,i(i({ref:n},l),{},{components:t})):r.createElement(m,i({ref:n},l))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<a;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},58380:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var r=t(87462),o=(t(67294),t(3905));const a={hide_table_of_contents:!0},i="Collision Detection",s={unversionedId:"examples/advanced/collision-detection",id:"examples/advanced/collision-detection",title:"Collision Detection",description:"",source:"@site/docs/examples/advanced/collision-detection.md",sourceDirName:"examples/advanced",slug:"/examples/advanced/collision-detection",permalink:"/examples/advanced/collision-detection",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/examples/advanced/collision-detection.md",tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"examplesSidebar",previous:{title:"Shader Toy Filter Render Texture",permalink:"/examples/filters-advanced/shader-toy-filter-render-texture"},next:{title:"Mouse Trail",permalink:"/examples/advanced/mouse-trail"}},c={},u=[],l={toc:u};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"collision-detection"},"Collision Detection"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:"playground",playground:!0},"import * as PIXI from 'pixi.js';\n\n// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\nconst app = new PIXI.Application({ background: '#111', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2)\n{\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y;\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2)\n{\n    if (!object1 || !object2)\n    {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(\n        object2.x - object1.x,\n        object2.y - object1.y,\n    );\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x)\n        + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(\n        vCollision.x / distance,\n        vCollision.y / distance,\n    );\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x\n        + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = impulsePower * speed / (object1.mass + object2.mass);\n\n    return new PIXI.Point(\n        impulse * vCollisionNorm.x,\n        impulse * vCollisionNorm.y,\n    );\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2)\n{\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = 0x00FF00;\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = 0xFF0000;\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\nconst mouseCoords = { x: 0, y: 0 };\n\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) =>\n{\n    mouseCoords.x = event.global.x;\n    mouseCoords.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > (app.screen.width - 100))\n    {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > (app.screen.height - 100))\n    {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if ((greenSquare.x < -30 || greenSquare.x > (app.screen.width + 30))\n        || greenSquare.y < -30 || greenSquare.y > (app.screen.height + 30))\n    {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0\n        || app.screen.height > mouseCoords.y || mouseCoords.y > 0)\n    {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + (redSquare.width * 0.5),\n            redSquare.y + (redSquare.height * 0.5),\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(\n            toMouseDirection.y,\n            toMouseDirection.x,\n        );\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(\n            mouseCoords,\n            redSquareCenterPosition,\n        );\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(\n            Math.cos(angleToMouse) * redSpeed,\n            Math.sin(angleToMouse) * redSpeed,\n        );\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare))\n    {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n\n        redSquare.acceleration.set(\n            (collisionPush.x * greenSquare.mass),\n            (collisionPush.y * greenSquare.mass),\n        );\n        greenSquare.acceleration.set(\n            -(collisionPush.x * redSquare.mass),\n            -(collisionPush.y * redSquare.mass),\n        );\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);\n")))}d.isMDXComponent=!0}}]);