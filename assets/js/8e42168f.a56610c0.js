"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[2192],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),u=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=u(e.components);return o.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=u(t),h=r,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||a;return t?o.createElement(m,s(s({ref:n},l),{},{components:t})):o.createElement(m,s({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var u=2;u<a;u++)s[u]=t[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},92095:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var o=t(87462),r=(t(67294),t(3905));const a={hide_table_of_contents:!0},s="Collision",i={unversionedId:"examples/demos-advanced/collision-detection",id:"examples/demos-advanced/collision-detection",title:"Collision",description:"",source:"@site/docs/examples/demos-advanced/collision-detection.md",sourceDirName:"examples/demos-advanced",slug:"/examples/demos-advanced/collision-detection",permalink:"/examples/demos-advanced/collision-detection",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/examples/demos-advanced/collision-detection.md",tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"examplesSidebar",previous:{title:"Screenshot",permalink:"/examples/demos-advanced/screenshot"},next:{title:"Spinners",permalink:"/examples/demos-advanced/spinners"}},c={},u=[],l={toc:u};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"collision"},"Collision"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"playground",playground:!0},"import * as PIXI from 'pixi.js';\n\n// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\nconst app = new PIXI.Application<HTMLCanvasElement>({ background: '#111', resizeTo: window });\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2) {\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y;\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2) {\n    if (!object1 || !object2) {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(\n        object2.x - object1.x,\n        object2.y - object1.y,\n    );\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x)\n        + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(\n        vCollision.x / distance,\n        vCollision.y / distance,\n    );\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x\n        + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = impulsePower * speed / (object1.mass + object2.mass);\n\n    return new PIXI.Point(\n        impulse * vCollisionNorm.x,\n        impulse * vCollisionNorm.y,\n    );\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2) {\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = 0x00FF00;\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = 0xFF0000;\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\nconst mouseCoords = { x: 0, y: 0 };\napp.stage.interactive = true;\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) => {\n    mouseCoords.x = event.global.x;\n    mouseCoords.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > (app.screen.width - 100)) {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > (app.screen.height - 100)) {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if ((greenSquare.x < -30 || greenSquare.x > (app.screen.width + 30))\n        || greenSquare.y < -30 || greenSquare.y > (app.screen.height + 30)) {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0\n        || app.screen.height > mouseCoords.y || mouseCoords.y > 0) {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + (redSquare.width * 0.5),\n            redSquare.y + (redSquare.height * 0.5),\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(\n            toMouseDirection.y,\n            toMouseDirection.x,\n        );\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(\n            mouseCoords,\n            redSquareCenterPosition,\n        );\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(\n            Math.cos(angleToMouse) * redSpeed,\n            Math.sin(angleToMouse) * redSpeed,\n        );\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare)) {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n        redSquare.acceleration.set(\n            (collisionPush.x * greenSquare.mass),\n            (collisionPush.y * greenSquare.mass),\n        );\n        greenSquare.acceleration.set(\n            -(collisionPush.x * redSquare.mass),\n            -(collisionPush.y * redSquare.mass),\n        );\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);\n")))}d.isMDXComponent=!0}}]);