"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[8206],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>h});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(r),m=a,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||l;return r?n.createElement(h,o(o({ref:t},c),{},{components:r})):n.createElement(h,o({ref:t},c))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:a,o[1]=i;for(var d=2;d<l;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},46104:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var n=r(87462),a=(r(67294),r(3905));const l={id:"PIXI.ProjectionSystem.pixi_core",title:"Class: PIXI.ProjectionSystem",sidebar_label:"PIXI.ProjectionSystem",custom_edit_url:null},o=void 0,i={unversionedId:"api/classes/PIXI.ProjectionSystem.pixi_core",id:"api/classes/PIXI.ProjectionSystem.pixi_core",title:"Class: PIXI.ProjectionSystem",description:"@pixi/core.ProjectionSystem",source:"@site/docs/api/classes/PIXI.ProjectionSystem.pixi_core.mdx",sourceDirName:"api/classes",slug:"/api/classes/PIXI.ProjectionSystem.pixi_core",permalink:"/api/classes/PIXI.ProjectionSystem.pixi_core",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{id:"PIXI.ProjectionSystem.pixi_core",title:"Class: PIXI.ProjectionSystem",sidebar_label:"PIXI.ProjectionSystem",custom_edit_url:null},sidebar:"apiSidebar",previous:{title:"PIXI.Program",permalink:"/api/classes/PIXI.Program.pixi_core"},next:{title:"PIXI.Quad",permalink:"/api/classes/PIXI.Quad.pixi_core"}},s={},d=[{value:"new PIXI.ProjectionSystem: <span><code>(renderer: Renderer) </code></span>",id:"new-pixiprojectionsystem-renderer-renderer-",level:3},{value:"Parameters:",id:"parameters",level:4},{value:"Members",id:"members",level:2},{value:"defaultFrame: <span><code>Rectangle</code></span>",id:"defaultframe-rectangle",level:3},{value:"destinationFrame: <span><code>Rectangle</code></span>",id:"destinationframe-rectangle",level:3},{value:"projectionMatrix: <span><code>Matrix</code></span>",id:"projectionmatrix-matrix",level:3},{value:"sourceFrame: <span><code>Rectangle</code></span>",id:"sourceframe-rectangle",level:3},{value:"transform: <span><code>PIXI.Matrix</code></span>",id:"transform-piximatrix",level:3},{value:"Methods",id:"methods",level:2},{value:"calculateProjection: <span><code>(_destinationFrame: Rectangle, sourceFrame: Rectangle, _resolution: number, root: boolean) -&gt; void</code></span>",id:"calculateprojection-_destinationframe-rectangle-sourceframe-rectangle-_resolution-number-root-boolean---void",level:3},{value:"Parameters:",id:"parameters-1",level:4},{value:"setTransform: <span><code>(_matrix: Matrix) -&gt; void</code></span>",id:"settransform-_matrix-matrix---void",level:3},{value:"Parameters:",id:"parameters-2",level:4},{value:"update: <span><code>(destinationFrame: Rectangle, sourceFrame: Rectangle, resolution: number, root: boolean) -&gt; void</code></span>",id:"update-destinationframe-rectangle-sourceframe-rectangle-resolution-number-root-boolean---void",level:3},{value:"Parameters:",id:"parameters-3",level:4}],c={toc:d};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"../modules/pixi_core"},"@pixi/core"),".ProjectionSystem"),(0,a.kt)("p",null,"System plugin to the renderer to manage the projection matrix.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"projectionMatrix")," is a global uniform provided to all shaders. It is used to transform points in world space to normalized device coordinates."),(0,a.kt)("p",null,"// TODO: @see"),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"new-pixiprojectionsystem-renderer-renderer-"},"new PIXI.ProjectionSystem: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"(renderer",":"," Renderer) "))),(0,a.kt)("h4",{id:"parameters"},"Parameters:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Default"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"renderer"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Renderer")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null)),(0,a.kt)("td",{parentName:"tr",align:null},"The renderer this System works for."))))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"members"},"Members"),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"defaultframe-rectangle"},"defaultFrame: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"Rectangle"))),(0,a.kt)("p",null,"Default destination frame\nThis is not used internally. It is not advised to use this feature specifically unless you know what you're doing. The ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," method will default to this frame if you do not pass the destination frame.")),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"destinationframe-rectangle"},"destinationFrame: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"Rectangle"))),(0,a.kt)("p",null,"The destination frame used to calculate the current projection matrix.\nThe destination frame is the rectangle in the render-target into which contents are rendered. If rendering to the screen, the origin is on the top-left. If rendering to a framebuffer, the origin is on the bottom-left. This \"flipping\" phenomenon is because of WebGL convention for (shader) texture coordinates, where the bottom-left corner is (0,0). It allows display-objects to map their (0,0) position in local-space (top-left) to (0,0) in texture space (bottom-left). In other words, a sprite's top-left corner actually renders the texture's bottom-left corner. You will also notice this when using a tool like SpectorJS to view your textures at runtime."),(0,a.kt)("p",null,"The destination frame's dimensions (width,height) should be equal to the source frame. This is because, otherwise, the contents will be scaled to fill the destination frame. Similarly, the destination frame's (x,y) coordinates are (0,0) unless you know what you're doing.")),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"projectionmatrix-matrix"},"projectionMatrix: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"Matrix"))),(0,a.kt)("p",null,"Projection matrix\nThis matrix can be used to transform points from world space to normalized device coordinates, and is calculated from the sourceFrame \u2192 destinationFrame mapping provided."),(0,a.kt)("p",null,"The renderer's ",(0,a.kt)("inlineCode",{parentName:"p"},"globalUniforms")," keeps a reference to this, and so it is available for all shaders to use as a uniform.")),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"sourceframe-rectangle"},"sourceFrame: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"Rectangle"))),(0,a.kt)("p",null,"The source frame used to calculate the current projection matrix.\nThe source frame is the rectangle in world space containing the contents to be rendered.")),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"transform-piximatrix"},"transform: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"PIXI.Matrix"))),(0,a.kt)("p",null,"A transform to be appended to the projection matrix.\nThis can be used to transform points in world-space one last time before they are outputted by the shader. You can use to rotate the whole scene, for example. Remember to clear it once you've rendered everything.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"calculateprojection-_destinationframe-rectangle-sourceframe-rectangle-_resolution-number-root-boolean---void"},"calculateProjection: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"(_destinationFrame",":"," Rectangle, sourceFrame",":"," Rectangle, _resolution",":"," number, root",":"," boolean) -",">"," void"))),(0,a.kt)("p",null,"Calculates the ",(0,a.kt)("inlineCode",{parentName:"p"},"projectionMatrix")," to map points inside ",(0,a.kt)("inlineCode",{parentName:"p"},"sourceFrame")," to inside ",(0,a.kt)("inlineCode",{parentName:"p"},"destinationFrame"),"."),(0,a.kt)("h4",{id:"parameters-1"},"Parameters:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"_destinationFrame"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Rectangle")),(0,a.kt)("td",{parentName:"tr",align:null},"The destination frame in the render-target.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sourceFrame"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Rectangle")),(0,a.kt)("td",{parentName:"tr",align:null},"The source frame in world space.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"_resolution"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"number")),(0,a.kt)("td",{parentName:"tr",align:null},"The render-target's resolution, i.e. ratio of CSS to physical pixels.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"root"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"boolean")),(0,a.kt)("td",{parentName:"tr",align:null},"Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection is y-flipped."))))),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"settransform-_matrix-matrix---void"},"setTransform: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"(_matrix",":"," Matrix) -",">"," void"))),(0,a.kt)("p",null,"Sets the transform of the active render target to the given matrix."),(0,a.kt)("h4",{id:"parameters-2"},"Parameters:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"_matrix"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Matrix")),(0,a.kt)("td",{parentName:"tr",align:null},"The transformation matrix"))))),(0,a.kt)("hr",null),(0,a.kt)("article",null,(0,a.kt)("h3",{id:"update-destinationframe-rectangle-sourceframe-rectangle-resolution-number-root-boolean---void"},"update: ",(0,a.kt)("span",null,(0,a.kt)("code",null,"(destinationFrame",":"," Rectangle, sourceFrame",":"," Rectangle, resolution",":"," number, root",":"," boolean) -",">"," void"))),(0,a.kt)("p",null,"Updates the projection-matrix based on the sourceFrame \u2192 destinationFrame mapping provided.\nNOTE",":"," It is expected you call ",(0,a.kt)("inlineCode",{parentName:"p"},"renderer.framebuffer.setViewport(destinationFrame)")," after this. This is because the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates."),(0,a.kt)("p",null,"NOTE-2",":"," ",(0,a.kt)("a",{parentName:"p",href:"../classes/PIXI.RenderTextureSystem.pixi_core#bind"},"PIXI.RenderTextureSystem#bind")," updates the projection-matrix when you bind a render-texture. It is expected that you dirty the current bindings when calling this manually."),(0,a.kt)("h4",{id:"parameters-3"},"Parameters:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"destinationFrame"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Rectangle")),(0,a.kt)("td",{parentName:"tr",align:null},"The rectangle in the render-target to render the contents into. If rendering to the canvas, the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sourceFrame"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"Rectangle")),(0,a.kt)("td",{parentName:"tr",align:null},"The rectangle in world space that contains the contents being rendered.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"resolution"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"number")),(0,a.kt)("td",{parentName:"tr",align:null},"The resolution of the render-target, which is the ratio of world-space (or CSS) pixels to physical pixels.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"root"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("code",null,"boolean")),(0,a.kt)("td",{parentName:"tr",align:null},"Whether the render-target is the screen. This is required because rendering to textures is y-flipped (i.e. upside down relative to the screen)."))))),(0,a.kt)("hr",null))}u.isMDXComponent=!0}}]);