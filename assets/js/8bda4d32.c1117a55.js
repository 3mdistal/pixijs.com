"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[50743],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>f});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=d(t),h=a,f=p["".concat(c,".").concat(h)]||p[h]||u[h]||i;return t?r.createElement(f,s(s({ref:n},l),{},{components:t})):r.createElement(f,s({ref:n},l))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=h;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[p]="string"==typeof e?e:a,s[1]=o;for(var d=2;d<i;d++)s[d]=t[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},77498:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=t(87462),a=(t(67294),t(3905));const i={hide_table_of_contents:!0},s="3D Cards",o={unversionedId:"examples/plugin-projection/cards",id:"examples/plugin-projection/cards",title:"3D Cards",description:"",source:"@site/docs/examples/plugin-projection/cards.md",sourceDirName:"examples/plugin-projection",slug:"/examples/plugin-projection/cards",permalink:"/examples/plugin-projection/cards",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/examples/plugin-projection/cards.md",tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"examplesSidebar",previous:{title:"3D Camera Spine Layers",permalink:"/examples/plugin-projection/camera-spine-layers"},next:{title:"3D Runner",permalink:"/examples/plugin-projection/runner"}},c={},d=[],l={toc:d};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"3d-cards"},"3D Cards"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:"playground",playground:!0},"import * as PIXI from 'pixi.js';\n\n// This examples is hard\n// To understand it, you have to carefully read all readme`s and other examples of respective plugins\n// Be ready to study the plugins code. Please use latest version of those libs\n// Used plugins: pixi-projection, pixi-display\n\nconst app = new PIXI.Application<HTMLCanvasElement>({ autoStart: false, antialias: true, resizeTo: window });\ndocument.body.appendChild(app.view);\napp.stage = new PIXI.display.Stage();\n\nconst { loader } = app;\n\nconst camera = new PIXI.projection.Camera3d();\ncamera.position.set(app.screen.width / 2, app.screen.height / 2);\ncamera.setPlanes(350, 30, 10000);\ncamera.euler.x = Math.PI / 5.5;\napp.stage.addChild(camera);\n\nconst cards = new PIXI.projection.Container3d();\ncards.position3d.y = -50;\n// MAKE CARDS LARGER:\ncards.scale3d.set(1.5);\ncamera.addChild(cards);\n\nconst shadowGroup = new PIXI.display.Group(1);\nconst cardsGroup = new PIXI.display.Group(2, ((item) => {\n    item.zOrder = -item.getDepth();\n    item.parent.checkFace();\n}));\n\n// Layers are 2d elements but we use them only to show stuff, not to transform items, so its fine :)\ncamera.addChild(new PIXI.display.Layer(shadowGroup));\ncamera.addChild(new PIXI.display.Layer(cardsGroup));\n// we could also add layers in the stage, but then we'll need extra layer for the text\n\n// load assets\nloader.add('cards', 'https://v2-pixijs.com/assets/pixi-projection/cards.json');\nloader.add('table', 'https://v2-pixijs.com/assets/pixi-projection/table.png');\nloader.load(onAssetsLoaded);\n\n// blur for shadow. Do not use it in production, bake shadow into the texture!\nconst blurFilter = new PIXI.filters.BlurFilter();\nblurFilter.blur = 0.2;\n\nclass CardSprite extends PIXI.projection.Container3d {\n    constructor() {\n        super();\n\n        const tex = loader.resources.cards.textures;\n\n        // shadow will be under card\n        this.shadow = new PIXI.projection.Sprite3d(tex['black.png']);\n        this.shadow.anchor.set(0.5);\n        this.shadow.scale3d.set(0.98);\n        this.shadow.alpha = 0.7;\n        // TRY IT WITH FILTER:\n        this.shadow.filters = [blurFilter];\n        // all shadows are UNDER all cards\n        this.shadow.parentGroup = shadowGroup;\n        this.inner = new PIXI.projection.Container3d();\n        // cards are above the shadows\n        // either they have back, either face\n        this.inner.parentGroup = cardsGroup;\n\n        this.addChild(this.shadow);\n        this.addChild(this.inner);\n\n        // construct \"inner\" from back and face\n        this.back = new PIXI.projection.Sprite3d(tex['cover1.png']);\n        this.back.anchor.set(0.5);\n        this.face = new PIXI.projection.Container3d();\n        this.inner.addChild(this.back);\n        this.inner.addChild(this.face);\n        this.code = 0;\n        this.showCode = -1;\n        this.inner.euler.y = Math.PI;\n        this.scale3d.set(0.2);\n\n        // construct \"face\" from four sprites\n        this.createFace();\n    }\n\n    createFace() {\n        const { face } = this;\n        face.removeChildren();\n        const tex = loader.resources.cards.textures;\n        const sprite = new PIXI.projection.Sprite3d(tex['white1.png']);\n        const sprite2 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        const sprite3 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        const sprite4 = new PIXI.projection.Sprite3d(PIXI.Texture.EMPTY);\n        sprite2.y = -120;\n        sprite2.x = -80;\n        sprite3.y = 70;\n        sprite3.x = 40;\n        sprite4.y = -70;\n        sprite4.x = -100;\n\n        sprite.anchor.set(0.5);\n        sprite2.anchor.set(0.5);\n        sprite3.anchor.set(0.5);\n        face.addChild(sprite);\n        face.addChild(sprite2);\n        face.addChild(sprite3);\n        face.addChild(sprite4);\n\n        this.updateFace();\n    }\n\n    updateFace() {\n        const tex = loader.resources.cards.textures;\n        const code = this.showCode === -1 ? 0 : this.showCode;\n        const num = code & 0xf;\n        const suit = code >> 4;\n\n        const { face } = this;\n        face.children[1].texture = num > 0 ? tex[`${suit % 2}_${num}.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[1].texture) {\n            console.log('FAIL 1 ', `${suit % 2}_${num}.png`);\n        }\n        face.children[2].texture = suit !== 0 ? tex[`${suit}_big.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[2].texture) {\n            console.log('FAIL 2', `${suit}_big.png`);\n        }\n        face.children[3].texture = suit !== 0 ? tex[`${suit}_small.png`] : PIXI.Texture.EMPTY;\n        if (!face.children[3].texture) {\n            console.log('FAIL 3', `${suit}_small.png`);\n        }\n    }\n\n    update(dt) {\n        const { inner } = this;\n        if (this.code > 0 && inner.euler.y > 0) {\n            inner.euler.y = Math.max(0, inner.euler.y - dt * 5);\n        }\n        if (this.code === 0 && inner.euler.y < Math.PI) {\n            inner.euler.y = Math.min(Math.PI, inner.euler.y + dt * 5);\n        }\n        inner.position3d.z = -Math.sin(inner.euler.y) * this.back.width;\n\n        // assignment is overriden, so its actually calling euler.copyFrom(this.euler)\n        this.shadow.euler = inner.euler;\n    }\n\n    checkFace() {\n        const { inner } = this;\n        let cc;\n\n        if (!inner.isFrontFace()) {\n        // user sees the back\n            cc = 0;\n        } else {\n        // user sees the face\n            cc = this.showCode || this.code;\n        }\n        if (cc === 0) {\n            this.back.renderable = true;\n            this.face.renderable = false;\n        } else {\n            this.back.renderable = false;\n            this.face.renderable = true;\n        }\n\n        if (cc !== this.showCode) {\n            this.showCode = cc;\n            this.updateFace();\n        }\n    }\n}\n\nfunction dealHand() {\n    cards.removeChildren();\n    for (let i = 0; i < 5; i++) {\n        const card = new CardSprite();\n        card.position3d.x = 56 * (i - 2);\n        if ((Math.random() * 3 | 0) === 0) {\n            onClick({ target: card });\n        }\n        card.update(0);\n        card.interactive = true;\n        card.on('mouseup', onClick);\n        card.on('touchend', onClick);\n        cards.addChild(card);\n    }\n}\n\nfunction onClick(event) {\n    const { target } = event;\n    if (target.code === 0) {\n        const num = (Math.random() * 13 | 0) + 2;\n        const suit = (Math.random() * 4 | 0) + 1;\n        target.code = suit * 16 + num;\n    } else {\n        target.code = 0;\n    }\n}\n\nfunction addText(txt) {\n    const style = {\n        fontSize: 80,\n        fontFamily: 'Arial',\n        fill: '#f5ffe3',\n        dropShadow: true,\n        dropShadowColor: 'rgba(1, 1, 1, 0.4)',\n        dropShadowDistance: 6,\n        wordWrap: false,\n    };\n    const basicText = new PIXI.projection.Text3d(txt, style);\n    basicText.position3d.x = -240;\n    basicText.position3d.y = 20;\n    camera.addChild(basicText);\n}\n\nfunction onAssetsLoaded() {\n    // background must be UNDER camera, it doesnt have z-index or any other bullshit for camera\n    app.stage.addChildAt(new PIXI.Sprite(loader.resources.table.texture), 0);\n    dealHand();\n    addText('Tap on cards');\n    // start animating\n    app.start();\n}\n\napp.ticker.add((deltaTime) => {\n    for (let i = 0; i < cards.children.length; i++) {\n        cards.children[i].update(deltaTime / 60.0);\n    }\n\n    // We are gonna sort and show correct side of card,\n    // so we need updateTransform BEFORE the sorting will be called.\n    // otherwise this part will be tardy by one frame\n    camera.updateTransform();\n});\n")))}p.isMDXComponent=!0}}]);