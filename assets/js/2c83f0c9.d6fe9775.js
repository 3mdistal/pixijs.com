"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[84066],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(r),h=a,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return r?n.createElement(m,i(i({ref:t},p),{},{components:r})):n.createElement(m,i({ref:t},p))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},64278:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const o={},i="Render Loop",s={unversionedId:"guides/basics/render-loop",id:"guides/basics/render-loop",title:"Render Loop",description:"Now that you understand the major parts of the system, let's look at how these parts work together to get your project onto the screen.  Unlike a web page, PixiJS is constantly updating and re-drawing itself, over and over.  You update your objects, then PixiJS renders them to the screen, then the process repeats.  We call this cycle the render loop.",source:"@site/docs/guides/basics/render-loop.md",sourceDirName:"guides/basics",slug:"/guides/basics/render-loop",permalink:"/guides/basics/render-loop",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/basics/render-loop.md",tags:[],version:"current",frontMatter:{},sidebar:"guidesSidebar",previous:{title:"Interaction",permalink:"/guides/basics/interaction"},next:{title:"Scene Graph",permalink:"/guides/basics/scene-graph"}},l={},c=[{value:"Running Ticker Callbacks",id:"running-ticker-callbacks",level:2},{value:"Updating the Scene Graph",id:"updating-the-scene-graph",level:2},{value:"Rendering the Scene Graph",id:"rendering-the-scene-graph",level:2},{value:"Frame Rates",id:"frame-rates",level:2},{value:"Custom Render Loops",id:"custom-render-loops",level:2}],p={toc:c};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"render-loop"},"Render Loop"),(0,a.kt)("p",null,"Now that you understand the major parts of the system, let's look at how these parts work together to get your project onto the screen.  Unlike a web page, PixiJS is constantly updating and re-drawing itself, over and over.  You update your objects, then PixiJS renders them to the screen, then the process repeats.  We call this cycle the render loop."),(0,a.kt)("p",null,"The majority of any PixiJS project is contained in this update + render cycle.  You code the updates, PixiJS handles the rendering."),(0,a.kt)("p",null,"Let's walk through what happens each frame of the render loop.  There are three main steps."),(0,a.kt)("h2",{id:"running-ticker-callbacks"},"Running Ticker Callbacks"),(0,a.kt)("p",null,"The first step is to calculate how much time has elapsed since the last frame, and then call the Application object's ticker callbacks with that time delta.  This allows your project's code to animate and update the sprites, etc. on the stage in preparation for rendering."),(0,a.kt)("h2",{id:"updating-the-scene-graph"},"Updating the Scene Graph"),(0,a.kt)("p",null,"We'll talk a ",(0,a.kt)("em",{parentName:"p"},"lot")," more about what a scene graph is and what it's made of in the next guide, but for now, all you need to know is that it contains the things you're drawing - sprites, text, etc. - and that these objects are in a tree-like hierarchy.  After you've updated your game objects by moving, rotating and so forth, PixiJS needs to calculate the new positions and state of every object in the scene, before it can start drawing."),(0,a.kt)("h2",{id:"rendering-the-scene-graph"},"Rendering the Scene Graph"),(0,a.kt)("p",null,"Now that our game's state has been updated, it's time to draw it to the screen.  The rendering system starts with the root of the scene graph (",(0,a.kt)("inlineCode",{parentName:"p"},"app.stage"),"), and starts rendering each object and its children, until all objects have been drawn.  No culling or other cleverness is built into this process.  If you have lots of objects outside of the visible portion of the stage, you'll want to investigate disabling them as an optimization."),(0,a.kt)("h2",{id:"frame-rates"},"Frame Rates"),(0,a.kt)("p",null,"A note about frame rates.  The render loop can't be run infinitely fast - drawing things to the screen takes time.  In addition, it's not generally useful to have a frame updated more than once per screen update (commonly 60fps, but newer monitors can support 144fps and up).  Finally, PixiJS runs in the context of a web browser like Chrome or Firefox.  The browser itself has to balance the needs of various internal operations with servicing any open tabs.  All this to say, determining when to draw a frame is a complex issue."),(0,a.kt)("p",null,"In cases where you want to adjust that behavior, you can set the ",(0,a.kt)("inlineCode",{parentName:"p"},"minFPS")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxFPS")," attributes on a Ticker to give PixiJS hints as to the range of tick speeds you want to support.  Just be aware that due to the complex environment, your project cannot ",(0,a.kt)("em",{parentName:"p"},"guarantee")," a given FPS.  Use the passed ",(0,a.kt)("inlineCode",{parentName:"p"},"delta")," value in your ticker callbacks to scale any animations to ensure smooth playback."),(0,a.kt)("h2",{id:"custom-render-loops"},"Custom Render Loops"),(0,a.kt)("p",null,"What we've just covered is the default render loop provided out of the box by the Application helper class.  There are many other ways of creating a render loop that may be helpful for advanced users looking to solve a given problem.  ","  While you're prototyping and learning PixiJS, sticking with the Application's provided system is the recommended approach."))}d.isMDXComponent=!0}}]);